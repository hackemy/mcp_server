#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Configuration — change these to match your app
# ─────────────────────────────────────────────────────────────────────────────
APP_NAME="${APP_NAME:-lemonsphere}"
DOMAIN="${DOMAIN:-${APP_NAME}.com}"
API_SUBDOMAIN="${API_SUBDOMAIN:-api}"
MCP_PORT="${MCP_PORT:-8080}"
WEB_ROOT="${WEB_ROOT:-/var/www/${DOMAIN}}"
NGINX_CONF_DIR="${NGINX_CONF_DIR:-/etc/nginx}"
CERTBOT_EMAIL="${CERTBOT_EMAIL:-}"

# Derived
API_DOMAIN="${API_SUBDOMAIN}.${DOMAIN}"
CONF_FILE="${NGINX_CONF_DIR}/sites-available/${APP_NAME}.conf"
ENABLED_LINK="${NGINX_CONF_DIR}/sites-enabled/${APP_NAME}.conf"

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")"/.. && pwd)"

# ─────────────────────────────────────────────────────────────────────────────
# Helpers
# ─────────────────────────────────────────────────────────────────────────────
info()  { echo -e "\033[1;34m→\033[0m $*"; }
ok()    { echo -e "\033[1;32m✓\033[0m $*"; }
warn()  { echo -e "\033[1;33m!\033[0m $*"; }
fail()  { echo -e "\033[1;31m✗\033[0m $*" >&2; exit 1; }

need_root() {
  if [[ $EUID -ne 0 ]]; then
    fail "This command must be run as root (use sudo)"
  fi
}

usage() {
  cat <<EOF
Usage: scripts/nginx.sh <command>

Commands:
  install     Install nginx + certbot (apt-based systems)
  configure   Generate nginx config and enable site
  certs       Obtain Let's Encrypt TLS certificates via certbot
  deploy-web  Create web root and deploy static site files
  setup       Run all of the above in order (full first-time setup)
  status      Show nginx status and config test
  help        Show this help

Environment overrides:
  APP_NAME        Application name           (default: lemonsphere)
  DOMAIN          Primary domain             (default: \${APP_NAME}.com)
  API_SUBDOMAIN   API subdomain prefix       (default: api)
  MCP_PORT        MCP server listen port     (default: 8080)
  WEB_ROOT        Static site document root  (default: /var/www/\${DOMAIN})
  CERTBOT_EMAIL   Email for Let's Encrypt    (required for certs)

Examples:
  sudo ./scripts/nginx.sh setup
  sudo APP_NAME=myapp DOMAIN=myapp.io CERTBOT_EMAIL=me@myapp.io ./scripts/nginx.sh setup
  sudo ./scripts/nginx.sh certs
EOF
}

# ─────────────────────────────────────────────────────────────────────────────
# install — apt install nginx + certbot
# ─────────────────────────────────────────────────────────────────────────────
cmd_install() {
  need_root
  info "Installing nginx and certbot..."

  if command -v apt-get &>/dev/null; then
    apt-get update -qq
    apt-get install -y -qq nginx certbot python3-certbot-nginx
  elif command -v dnf &>/dev/null; then
    dnf install -y nginx certbot python3-certbot-nginx
  elif command -v yum &>/dev/null; then
    yum install -y nginx certbot python3-certbot-nginx
  else
    fail "Unsupported package manager. Install nginx and certbot manually."
  fi

  # Enable nginx to start on boot
  systemctl enable nginx 2>/dev/null || true

  ok "nginx $(nginx -v 2>&1 | cut -d/ -f2) installed"
  ok "certbot $(certbot --version 2>&1 | awk '{print $2}') installed"
}

# ─────────────────────────────────────────────────────────────────────────────
# configure — write nginx config and enable site
# ─────────────────────────────────────────────────────────────────────────────
cmd_configure() {
  need_root
  info "Generating nginx config for ${DOMAIN}..."

  mkdir -p "${NGINX_CONF_DIR}/sites-available" "${NGINX_CONF_DIR}/sites-enabled"

  # Check if certs exist to decide between HTTPS and HTTP-only config
  local has_certs=false
  if [[ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]]; then
    has_certs=true
  fi

  if $has_certs; then
    write_full_config
  else
    write_http_only_config
    warn "No TLS certs found — wrote HTTP-only config for initial certbot run"
    warn "Run 'nginx.sh certs' then 'nginx.sh configure' again for full HTTPS"
  fi

  # Enable site
  rm -f "$ENABLED_LINK"
  ln -s "$CONF_FILE" "$ENABLED_LINK"

  # Remove default site if it exists (conflicts with port 80)
  rm -f "${NGINX_CONF_DIR}/sites-enabled/default"

  # Test config
  nginx -t 2>&1 || fail "nginx config test failed"

  # Reload
  systemctl reload nginx 2>/dev/null || nginx -s reload 2>/dev/null || true

  ok "Config written to ${CONF_FILE}"
  ok "Site enabled and nginx reloaded"
}

write_http_only_config() {
  cat > "$CONF_FILE" <<NGINX
# ─────────────────────────────────────────────────────────────────
# ${APP_NAME} — HTTP-only (pre-certbot)
# Generated by scripts/nginx.sh — do not edit manually
# ─────────────────────────────────────────────────────────────────

server {
    listen 80;
    server_name ${DOMAIN} www.${DOMAIN} ${API_DOMAIN};

    # Certbot challenge directory
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        allow all;
    }

    # Static site (temporary, until certs are issued)
    root ${WEB_ROOT};
    index index.html;

    location / {
        try_files \$uri \$uri/ /index.html;
    }
}
NGINX
}

write_full_config() {
  cat > "$CONF_FILE" <<NGINX
# ─────────────────────────────────────────────────────────────────
# ${APP_NAME} — production config
# Generated by scripts/nginx.sh — do not edit manually
# ─────────────────────────────────────────────────────────────────

# ── Rate limiting ────────────────────────────────────────────────
limit_req_zone \$binary_remote_addr zone=api:10m rate=30r/s;

# ── HTTP → HTTPS redirect (all domains) ─────────────────────────
server {
    listen 80;
    server_name ${DOMAIN} www.${DOMAIN} ${API_DOMAIN};

    # Keep certbot challenge accessible
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        allow all;
    }

    location / {
        return 301 https://\$host\$request_uri;
    }
}

# ── www → non-www redirect (HTTPS) ──────────────────────────────
server {
    listen 443 ssl;
    http2 on;
    server_name www.${DOMAIN};

    ssl_certificate     /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    return 301 https://${DOMAIN}\$request_uri;
}

# ── Main site — static SPA / marketing ──────────────────────────
server {
    listen 443 ssl;
    http2 on;
    server_name ${DOMAIN};

    ssl_certificate     /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    root ${WEB_ROOT};
    index index.html;

    # SPA — fallback to index.html for client-side routing
    location / {
        try_files \$uri \$uri/ /index.html;
    }

    # Static assets — long-lived cache
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?|ttf|eot|webp|avif)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options    nosniff always;
    add_header X-Frame-Options           DENY always;
    add_header Referrer-Policy           strict-origin-when-cross-origin always;
}

# ── API / MCP server ────────────────────────────────────────────
upstream mcp_backend {
    server 127.0.0.1:${MCP_PORT};
    keepalive 16;
}

server {
    listen 443 ssl;
    http2 on;
    server_name ${API_DOMAIN};

    ssl_certificate     /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    include             /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam         /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options    nosniff always;
    add_header X-Frame-Options           DENY always;

    # MCP endpoint — streaming support
    location /mcp {
        limit_req zone=api burst=60 nodelay;

        proxy_pass         http://mcp_backend;
        proxy_http_version 1.1;
        proxy_buffering    off;
        proxy_read_timeout 300s;
        proxy_send_timeout 300s;

        proxy_set_header Host              \$host;
        proxy_set_header X-Real-IP         \$remote_addr;
        proxy_set_header X-Forwarded-For   \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header Connection        "";
    }

    # Health check (no rate limit)
    location /healthz {
        proxy_pass http://mcp_backend;
    }

    # Block everything else
    location / {
        return 404;
    }
}
NGINX
}

# ─────────────────────────────────────────────────────────────────────────────
# certs — obtain Let's Encrypt certificates
# ─────────────────────────────────────────────────────────────────────────────
cmd_certs() {
  need_root

  if [[ -z "$CERTBOT_EMAIL" ]]; then
    fail "CERTBOT_EMAIL is required. Export it or pass it: CERTBOT_EMAIL=you@example.com"
  fi

  # Ensure certbot webroot exists
  mkdir -p /var/www/certbot

  # If nginx is already running with HTTP config, use webroot plugin
  # Otherwise fall back to standalone (stops nginx briefly)
  if systemctl is-active nginx &>/dev/null; then
    info "Obtaining certs via nginx plugin for ${DOMAIN}, www.${DOMAIN}, ${API_DOMAIN}..."
    certbot --nginx \
      -d "${DOMAIN}" \
      -d "www.${DOMAIN}" \
      -d "${API_DOMAIN}" \
      --email "$CERTBOT_EMAIL" \
      --agree-tos \
      --no-eff-email \
      --non-interactive \
      --redirect
  else
    info "nginx not running — using standalone mode..."
    certbot certonly --standalone \
      -d "${DOMAIN}" \
      -d "www.${DOMAIN}" \
      -d "${API_DOMAIN}" \
      --email "$CERTBOT_EMAIL" \
      --agree-tos \
      --no-eff-email \
      --non-interactive
  fi

  ok "Certificates obtained for ${DOMAIN}"

  # Set up auto-renewal timer if not already present
  if ! systemctl is-enabled certbot.timer &>/dev/null 2>&1; then
    systemctl enable --now certbot.timer 2>/dev/null || true
    ok "Certbot auto-renewal enabled"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# deploy-web — create web root and placeholder
# ─────────────────────────────────────────────────────────────────────────────
cmd_deploy_web() {
  need_root
  info "Setting up web root at ${WEB_ROOT}..."

  mkdir -p "$WEB_ROOT"

  # Only write placeholder if index.html doesn't exist
  if [[ ! -f "${WEB_ROOT}/index.html" ]]; then
    cat > "${WEB_ROOT}/index.html" <<HTML
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>${APP_NAME}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; display: grid; place-items: center; min-height: 100vh; background: #0a0a0a; color: #fafafa; }
    h1 { font-size: 3rem; font-weight: 200; letter-spacing: 0.05em; }
    p { margin-top: 1rem; color: #888; }
  </style>
</head>
<body>
  <div>
    <h1>${APP_NAME}</h1>
    <p>coming soon</p>
  </div>
</body>
</html>
HTML
    ok "Placeholder index.html created"
  else
    ok "index.html already exists — skipped"
  fi

  # Set ownership to www-data (nginx worker user)
  chown -R www-data:www-data "$WEB_ROOT"
  chmod -R 755 "$WEB_ROOT"

  ok "Web root ready at ${WEB_ROOT}"
}

# ─────────────────────────────────────────────────────────────────────────────
# setup — full first-time setup
# ─────────────────────────────────────────────────────────────────────────────
cmd_setup() {
  need_root

  echo ""
  info "Full setup for ${APP_NAME}"
  info "  Domain:     ${DOMAIN}"
  info "  API:        ${API_DOMAIN}"
  info "  MCP port:   ${MCP_PORT}"
  info "  Web root:   ${WEB_ROOT}"
  echo ""

  # 1. Install packages
  cmd_install

  # 2. Create web root
  cmd_deploy_web

  # 3. Write HTTP-only config so nginx can serve certbot challenges
  cmd_configure

  # 4. Get certs (requires DNS already pointing to this server)
  if [[ -n "$CERTBOT_EMAIL" ]]; then
    cmd_certs
    # 5. Re-generate config with full HTTPS now that certs exist
    cmd_configure
  else
    warn "CERTBOT_EMAIL not set — skipping certificate issuance"
    warn "Set it and run: sudo CERTBOT_EMAIL=you@${DOMAIN} ./scripts/nginx.sh certs"
    warn "Then re-run:    sudo ./scripts/nginx.sh configure"
  fi

  echo ""
  ok "Setup complete!"
  echo ""
  info "Next steps:"
  if [[ -z "$CERTBOT_EMAIL" ]]; then
    echo "  1. Point DNS A records for ${DOMAIN}, www.${DOMAIN}, ${API_DOMAIN} to this server"
    echo "  2. sudo CERTBOT_EMAIL=you@${DOMAIN} ./scripts/nginx.sh certs"
    echo "  3. sudo ./scripts/nginx.sh configure"
    echo "  4. Start the MCP server: cargo run (or via systemd)"
  else
    echo "  1. Start the MCP server: cargo run (or via systemd)"
    echo "  2. Test: curl https://${API_DOMAIN}/healthz"
    echo "  3. Deploy your SPA to ${WEB_ROOT}/"
  fi
  echo ""
}

# ─────────────────────────────────────────────────────────────────────────────
# status — show current state
# ─────────────────────────────────────────────────────────────────────────────
cmd_status() {
  echo ""
  info "nginx status"
  echo "  Config file:  ${CONF_FILE}"
  echo "  Enabled link: ${ENABLED_LINK}"
  echo "  Web root:     ${WEB_ROOT}"
  echo ""

  if [[ -f "$CONF_FILE" ]]; then
    ok "Config exists"
  else
    warn "Config not found"
  fi

  if [[ -L "$ENABLED_LINK" ]]; then
    ok "Site enabled"
  else
    warn "Site not enabled"
  fi

  if [[ -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" ]]; then
    local expiry
    expiry=$(openssl x509 -enddate -noout -in "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem" 2>/dev/null | cut -d= -f2)
    ok "TLS cert valid until: ${expiry}"
  else
    warn "No TLS cert found for ${DOMAIN}"
  fi

  echo ""
  if systemctl is-active nginx &>/dev/null 2>&1; then
    ok "nginx is running"
  else
    warn "nginx is not running"
  fi

  echo ""
  info "Config test:"
  nginx -t 2>&1 || true
  echo ""
}

# ─────────────────────────────────────────────────────────────────────────────
# main
# ─────────────────────────────────────────────────────────────────────────────
main() {
  local cmd=${1:-help}
  case "$cmd" in
    install)    cmd_install ;;
    configure)  cmd_configure ;;
    certs)      cmd_certs ;;
    deploy-web) cmd_deploy_web ;;
    setup)      cmd_setup ;;
    status)     cmd_status ;;
    help|--help|-h) usage ;;
    *) echo "Unknown command: $cmd" >&2; usage; exit 1 ;;
  esac
}

main "$@"
